////////////////////////////////////////////////////////////////////////////////
//////////      Google Earth Engine Mangrove Mapping Methodology     ///////////
////////////////////////////////////////////////////////////////////////////////

/* 

This code was developed for Blue Ventures Conservation, by Max Yancho.
Questions about the project and the application of the script(s) should be 
directed to Dr. Trevor Jones, Geospatial & Blue Forests Science adviser 
(trevor@blueventures.org). Questions about the code can be directed to 
Mr. Max Yancho (yanchojo@gmail.com).

Developed on June 3, 2020
Last updated November 2, 2020

Throughout this tool you will find references to the user name 'yanchojo'. This 
is Mr. Yancho's (the primary developer) personal Google account. Future 
iterations of the Google Earth Engine Mangrove Mapping Methodology (GEEMMM) tool
will be hosted by a Blue Ventures Conservation Google account.


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////
//////////////      Step 1       //////////////
///////////////////////////////////////////////


1.A) USER DEFINED DATA SETS
     In this first sub-section the user must determine what data they would 
     like to use within the Mangrove Mapping Methodology (MMM). For each, 
     two options are usually presented: use GEE data or upload user-owned
     data. Additionally, if the user would like, they may file a request to
     Google to add a specific data set into the 'Earth Engine Data Catalog'
     To submit a data request follow the below link:
          https://developers.google.com/earth-engine/help#dataset_requests
          Note: This will likely not be a very quick service/response.   

1.A.a) Set Coarse ROI
     The user must first coarsely define their region of interest (ROI). To 
     do so, please use the drawing tools located in the upper left corner of
     the 'Map' to roughly define the part of the world to further investigate.
     The current methodology only supports the use of the ‘Draw a shape’ or 
     ‘Draw a rectangle’ drawing tools at this time. Note: this is not going to 
     be the ROI used in the data processing, this coarse ROI is to simply help 
     select the target data. The geometry that you create must be renamed to 
     "coarse_roi"; this can be done by double-clicking the newly drawn geometry
     in the script's 'Imports' (located at the top of the script).

1.A.b) Known Mangrove Extent
     The currently known mangrove extent for the study area will play a key role
     in the further identification of methodological variables (such as slope 
     and elevation thresholds). At this time, the user must identify whether GEEEMMM 
     will use the GEE provided Global Mangrove Forests Distribution, v1 (2000), or 
     an alternative ‘known mangrove’ asset which has been uploaded to the user’s 
     account.
     
     Enter:
          var kmx = true; (to use the GEE Global Mangrove Forests Distribution)
          var kmx = false; (to map to the user's 'known mangrove extent' asset)
*/

var kmx = true;

/*
1.A.c) Coastline Data
     The coastline is a very important data set for this workflow. It will be 
     used to define the actual ROI, as well as to aid in the determination of the
     tidal conditions for each of the landsat images which are to be processed. 
     The coastline layer available in GEE is the Large Scale International 
     Boundary Polygons. Alternatively, as per the known mangrove extent, the user 
     may upload their own data as an asset and bring it into the workflow by 
     copying in the asset path into the 'cst_path' variable below.
     
     Enter:
          var cst = true; (the GEE Large Scale International Boundary Polygons)
          var cst = false; (to map to the user's uploaded 'coastline' asset)
                            ^--- Must enter an asset path
*/

var cst = false; 
var cst_path = 'users/yanchojo/gadm36_mmr_0_shore';

/*
1.A.d) Topographic Data 
     Another important variable is that of the topographic data. The topographic 
     data will be used to set elevation and slope thresholds before the 
     classification is executed. The default GEEMMM topographic data is from the
     JAXA-ALOS satellite radar DSM (30 m). As is the case with the other important
     data inputs, the user has the choice to upload their own data by filling in 
     the 'topo_path' variable below.
     
     Enter:
          var topo = true; (to use the GEE JAXA-ALOS satellite radar DSM (30 m))
          var topo = false; (to map to the user's uploaded 'topographic' asset)
                              ^--- Must enter an asset path
*/

var topo = true;
var topo_path = 'users/yanchojo/topo';


////////////////////////////////////////////////////////////////////////////////
/*
1.B) USER DEFINED VARIABLE
    In this sub-section, the user will have to define some variables about how 
    the GEEMMM will run. These variables include the historic and contemporary year
    windows, topographic thresholds, cloud cover limits, etc. Each variable will
    be described thoroughly, and helpful resources provided for further insight.


1.B.a) Contemporary Years
     Define the contemporary year window. These years will bookend the data 
     selected. The years selected are completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example 
     below. Note: If a single year is desired, put the same year for both 
     variables.
     
     Enter:
          var contemporary_start_year = 2014; (Later Contemporary year)
          var Contemporary_end_year = 2018; (Earlier Contemporary year)
*/

var contemporary_start_year = 2018;
var contemporary_end_year = 2020;

/*
1.B.b) Historic Years
     Define the historic year window. These years will bookend the data 
     selected. The years selected are completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example below.
     Note: If a single year is desired, put the same year for both variables.
  
     Enter:
          var historic_start_year = 2004; (Later Historic year)
          var historic_end_year = 2008; (Earlier Historic year)

*/

var historic_start_year = 2004;
var historic_end_year = 2008;

/*
1.B.c) Months of Interest 
     Define the months of interest. Like the year windows of interest, the 
     months of interest entered by the user will be used to filter both of the
     imagery sets (contemporary and historic). Two months are required to be 
     input by the user. If they wish to cover the entire year, ‘1’ and ‘12’ 
     should be selected (for January and December). Importantly, the months may
     overlap the new year; e.g.  “11” (Nov.) to “2” (Feb.).
     
     The time of year selected should focus on a few key environmental variables
     that will impact the imagery. These include:
      1.) The contrast of mangrove vegetation from surrounding land cover.
      2.) The persistence of clouds in the region (e.g. dry or wet seasons).
     
     Region-specific knowledge of the study area should be used to support the 
     decision around the selection of seasonal month range. If the user needs to
     learn more about the seasonality of the study area they may refer to the
     RiceAtlas database as one source of seasonality info (Laborte et al, 2017). 
     (https://www.nature.com/articles/sdata201774)
     
     Note: If a single month is desired, put the same month for both variables.
     
     Enter:
          (Jan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6, Jul = 7, Aug = 8,
          Sep = 9, Oct = 10, Nov = 11, Dec = 12)
          
          var month_start = 1; **To select the whole year set to 1**
          var month_end = 12; **To select the whole year set to 12**
*/

var month_start = 1;
var month_end = 12;

/*
1.B.d) Cloud Cover limit  
     The cloud cover limit is a whole number percentage that will be used to 
     filter the Landsat image collection. The cloud cover limit will filter the
     metadata of each image, using the USGS calculated  cloud cover in the Tier
     1 products. 
     (https://www.usgs.gov/core-science-systems/nli/landsat/cfmask-algorithm)
    
     Enter:
          var cloud_cover = 10; (%, 0-100, Integer)

*/

var cloud_cover = 5;

/*
1.B.e) Tidal Zone  
     The tidal zone is a user-defined parameter that is used to help the GEEMMM 
     determine the tidal condition for each image, in both the historic and the
     contemporary image sets. The tidal zone is functionally a shoreline buffer
     which extends seawards from the shore. The distance should be the tidally 
     'active' zone, which will contain the majority of the tidal flats and tidal
     islands which would be exposed and then resubmerged given the tidal state.
     
     The default number is 1000 m (1 km). This number can be tailored for the
     specific region of interest. **NOTE: The tidal zone is not the ROI.**
    
     Enter:
          var tidal_zone = 1000; (meters, Integer)

*/

var tidal_zone = 1000;


/*
1.B.f) Water Mask
     The GEEMMM offers the option to mask out water pixels using the MNDWI index.
     The MNDWI is calculated for the entire ROI and water pixels are removed 
     based on a threshold established in the original paper by Dr. H. Xu (2006).
     If water pixels are not masked, the reference training data must take this 
     into account in some fashion (e.g. "water_class").

     Enter:
          var remove_water = true; (mask out the water pixels using MNDWI)
          var remove_water = false; (water pixels will NOT be masked)
    
    If the water pixels are to be masked, the user has the option to either mask
    pixels which are water in both the historic and contemporary imagery, or to
    just mask pixels that were identified as water in the historic imagery. If 
    the coastline has changed dramatically during the time period of interest, a
    combined mask will be best, to not erroneously mask non-water pixels. 
    
    Enter:
          var combo_water_mask = true; (mask only pixels identified as 
                                        water in historic and contemporary data)
          var combo_water_mask = false;  (mask only pixels identified as 
                                          water in historic data)
*/

var remove_water = true;
var combo_water_mask = true;

/*
1.B.g) Inland Fringing Mangroves
     Studies have shown that inland stands of mangroves may be found at low-lying
     elevations which are far from the coastline. For a comprehensive investigation,
     these exclaves must attempt to be captured. To do so, the ROI can be expanded 
     to 2x to account for low-lying elevations beyond the initial determination.
     
     Example: If the ROI is determined to be a 25 km buffer of the coastline, if 
              'true', the ROI will be expanded to include all pixels between 25 
              and 50 km which also fall at or below 5 m a.s.l.

     Enter:
          var inland_mang = true; (true, double the ROI for pixels <= 5 m a.s.l)
          var inland_mang = false; (false, retain original ROI)
*/

var inland_mang = false;

/*

1.B.h) Topographic Thresholds
     To threshold the data, the user has several options: 1.) The known mangrove
     extent can be used to extract the 99th percentile for slope and elevation,
     this then used to generate a topographic mask for the input data. OR 2.) The
     user may enter their own thresholds for both slope and elevation. NOTE: If
     the user elects to have the data automatically thresholded ('true') then the
     numbers entered here for the slope and elevation threshold will have no impact
     on the generation of the topographic mask.

     Enter:
          var mang_topo = true; (use the known mangrove extent to determine
                                 the 99th percentiles for slope and elevation, 
                                 and use these to automatically generate a 
                                 topographic mask.)
          var mang_topo = false; (use the user defined thresholds to 
                                  generate the topographic mask.)
     
     The user defined topographic thresholds: (discarded if mang_topo = true)
     
     Enter:
          var elevation = 39; (meters, meters above sea level)
          var slope = 16; (%, percent change in slope)
*/

var mang_topo = true;
var elevation = 39;
var slope = 16;

/*
1.B.i) Cloud Mask
     There are three options available to mask out clouds. First, clouds can be
     left as is. This may be ideal if the imagery is known to be very free of 
     cloud contamination - this may correspond with a lower cloud cover limit
     threshold (i.e. >= 5%). Next, there is a mild cloud masking options where 
     the clouds are removed using the USGS/NASA bit classification quality band
     and a mild spectral erosion to remove cloud artefacts. Finally, there is an
     aggressive cloud masking option. This method removes pixels based on how 'white'
     they are in the visible spectrum bands. The thermal band also plays a role in 
     removing residual clouds. These identified clouds are also spectrally eroded. 
     
     Enter Below:
        var cloud_mask = 'none';        (No cloud mask applied)
        var cloud_mask = 'mild';        (To apply a mild cloud mask)
        var cloud_mask = 'aggressive';  (To apply an aggressive cloud mask)

*/

var cloud_mask = 'none';

/*
1.B.j) Spectral Indices
     There are numerous mangrove-specific, vegetation-specific, and 
     environmental indices which can be used to aid the classification. Below is
     the included list of indices which the user may select from. The user will 
     be prompted in the console to select any index which they would like to 
     include for each dataset moving forward. Note: Some indices, like the 
     submerged mangrove recognition index (SMRI) require both high and low tide 
     imagery. This will be indicated with (l) for low and (h) for high inputs.
     
     
    ############################################################################
    #    Index    #          Calculation          #        Citation            #
    ############################################################################ 
    #                                                                          #
    #   SR('RVI')   = NIR/Red                            Jordan 1969           #
    #                                                                          #
    #   NDVI        = (NIR-Red)/(NIR+Red)                Tarpley et al. 1984   #
    #                                                                          #
    #   NDWI        = (Green-NIR)/(Green+NIR)            Gao 1996              # 
    #                                                                          #
    #   MNDWI       = (Green-SWIR1)/(Green+SWIR1)        Xu 2006               #
    #                                                                          #
    #   CMRI        = NDVI-NDWI                          Gupta et al. 2018     #
    #                                                                          #
    #   MMRI        = (MNDWI-NDVI)/(MNDWI+NDVI)          Diniz et al. 2018     #
    #                                                                          #
    #   SAVI        = 1.5*(NIR-Red)/(NIR+Red+0.5)        Huete 1988            #
    #                                                                          #
    #   OSAVI       = (NIR-Red)/(NIR+Red+0.16)           Rondeaux et al. 1996  #
    #                                                                          #
    #   EVI         = 2.5*((NIR–red)/                    Huete et al. 1999     #
    #                       (NIR+6*Red–7.5*Blue+1))                            #
    #                                                                          #
    #   MRI         = |GVI(l) – GVI(h)|*GVI(l)*         Zhang and Tian 2013    #
    #                                 (WI(l)+WI(h))                            #
    #                                                                          #
    #   SMRI        = (NDVI(l)-NDVI(h))*                Xia et al. 2018        #
    #                       ((NIR(l)-NIR(h))/(NIR(h))                          # 
    #                                                                          #
    #   LWSI        = (NIR- SWIR1)/(NIR+ SWIR1)       Chandrasekar et al. 2010 # 
    #                                                                          #
    #   NDTI        = (MIR-SWIR2)/(MIR+SWIR2)         Van Deventer et al. 1997 #
    #                                                                          #
    #   EBBI        = (SWIR1-NIR)/(10*√( SWIR1+LWIR))   As-syakur et al. 2012  #
    #                                                                          # 
    ############################################################################
    
    
    
    ****************************************************************************
    **********************   Click 'Begin Workflow' Now   **********************
    ****************************************************************************
    
    
    
      ** This line marks the end of the user defined inputs and variables. **
*/

























////////////////////////////////////////////////////////////////////////////////
// Required Modules

var known_ext =  require('users/yanchojo/GEEMMM_v4_1/:modules/known_mangroves');
var coastline =  require('users/yanchojo/GEEMMM_v4_1/:modules/coastline');
var topography =  require('users/yanchojo/GEEMMM_v4_1/:modules/topography');
var mangrove_buff = require('users/yanchojo/GEEMMM_v4_1/:modules/mangrove_buff');
var c_imagery = require('users/yanchojo/GEEMMM_v4_1/:modules/contemporary_imagery');
var h_imagery = require('users/yanchojo/GEEMMM_v4_1/:modules/historic_imagery');
var shoreRefl = require('users/yanchojo/GEEMMM_v4_1/:modules/MNDWI_tidal_function');
var indx_mod = require('users/yanchojo/GEEMMM_v4_1/:modules/indices');
var water = require('users/yanchojo/GEEMMM_v4_1/:modules/water_mask');
var fringe = require('users/yanchojo/GEEMMM_v4_1/:modules/fringe_mang');



////////////
// Step 1 //
////////////
var step_1_button = ui.Button('Begin Workflow');
step_1_button.onClick(function(){
  //1.A.a
  //Map.clear(); 

  //1.A.b Ingest the known mangrove extent
  var mang_img = known_ext.known_mang(kmx);
  //1.A.c Ingest the topographic data (DSM)
  var dsm = topography.dsm_id(topo);
  //1.A.d Create the coastline from the coarse ROI
  var coast = coastline.coast_In(cst, cst_path, coarse_roi);
  Map.centerObject(coarse_roi);
  
  //Aside: in the meantime create the tidal area buffer
  var tidalArea = coast.simplify(500).buffer(tidal_zone).simplify(500);
  
  //1.B.k Generate the index list
  var indx = ee.List([]);
  var SR = ui.Checkbox('SR', false);
  SR.onChange(function() {
    // Add the index to the list.
    indx = indx.add('SR');
    return indx;});

  var NDVI = ui.Checkbox('NDVI', false);
  NDVI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('NDVI');
    return indx;});

  var NDWI = ui.Checkbox('NDWI', false);
  NDWI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('NDWI');
    return indx;});

  var MNDWI = ui.Checkbox('MNDWI', false);
  MNDWI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('MNDWI');
    return indx;});
  
  var CMRI = ui.Checkbox('CMRI', false);
  CMRI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('CMRI');
    return indx;});

  var MMRI = ui.Checkbox('MMRI', false);
  MMRI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('MMRI');
    return indx;});

  var SAVI = ui.Checkbox('SAVI', false);
  SAVI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('SAVI');
    return indx;});

  var OSAVI = ui.Checkbox('OSAVI', false);
  OSAVI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('OSAVI');
    return indx;});

  var EVI = ui.Checkbox('EVI', false);
  EVI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('EVI');
    return indx;});
  
  var MRI = ui.Checkbox('MRI', false);
  MRI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('MRI');
    return indx;});

  var SMRI = ui.Checkbox('SMRI', false);
  SMRI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('SMRI');
    return indx;});

  var LSWI = ui.Checkbox('LSWI', false);
  LSWI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('LSWI');
    return indx;});    

  var NDTI = ui.Checkbox('NDTI', false);
  NDTI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('NDTI');
    return indx;});    

  var EBBI = ui.Checkbox('EBBI', false);
  EBBI.onChange(function() {
    // Add the index to the list.
    indx = indx.add('EBBI');
    return indx;});    

    

  print(SR);
  print(NDVI);
  print(NDWI);
  print(MNDWI);
  print(CMRI);
  print(MMRI);
  print(SAVI);
  print(OSAVI);
  print(EVI);
  print(MRI);
  print(SMRI);
  print(LSWI);
  print(NDTI);
  print(EBBI);
  
  var button = ui.Button({
  label: 'Print Index List',
  onClick: function() {
    print('Index List', indx.distinct());
    return ee.List(indx.distinct());
    }
  });
  print(button);
  

  ////////////
  // Step 2 //
  ////////////
  var step_2_button = ui.Button('Determine ROI');
  step_2_button.onClick(function(){
    var indx_list = indx;

    //Buffer the known mangrove extent using the coastline
    var mang_buff_img = mangrove_buff.mang_buff(coast, mang_img);

    //Create a table of the mangrove area
    var buffer_table = mangrove_buff.areaTable(mang_buff_img, coarse_roi);

    //Graphically display mangrove area table
    var buffer_chart = mangrove_buff.areaChart(mang_buff_img, coarse_roi); 
    
    //Add the mangrove buffer layers to the map
    Map.addLayer(mang_buff_img.select('35_km'), {palette: ['CC0000']}, '35km_buffer');
    Map.addLayer(mang_buff_img.select('30_km'), {palette: ['FF780A']}, '20km_buffer');
    Map.addLayer(mang_buff_img.select('25_km'), {palette: ['FC9F0D']}, '25km_buffer');
    Map.addLayer(mang_buff_img.select('20_km'), {palette: ['F9CB24']}, '20km_buffer');
    Map.addLayer(mang_buff_img.select('15_km'), {palette: ['74B800']}, '15km_buffer');
    Map.addLayer(mang_buff_img.select('10_km'), {palette: ['3E8F00']}, '10km_buffer');
    Map.addLayer(mang_buff_img.select('05_km'), {palette: ['006600']}, '05km_buffer');
    //Print the chart and table to the console
    print("Mangrove Area by Buffer", buffer_table);
    print(buffer_chart);
    //Have the user set the buffer distance and create ROI.
    var ROI = ee.Geometry(coast);
    var buff_dist = ee.Number(0);
    // list of buffers to choose from
    var buffers = {
     '01_km': [1000], '02.5_km': [2500], '05_km': [5000], '07.5_km': [7500],
     '10_km': [10000], '12.5_km': [12500], '15_km': [15000], '17.5_km': [17500],
     '20_km': [20000], '22.5_km': [22500], '23_km': [23000], '25_km': [25000], '27.5_km': [27500],
     '30_km': [30000], '32.5_km': [32500], '35_km': [35000], '37.5_km': [37500],
     '40_km': [40000], '50_km': [50000], '60_km': [60000], '75_km': [75000],
    };
    // Create drop-down menu to select ROI buffer
    var select_ROI = ui.Select({
      items: Object.keys(buffers),
      onChange: function(key) {
      ROI = coast.buffer(buffers[key][0]);
      buff_dist = ee.Number(buffers[key][0]);
      }
    });

    // Set a place holder for the drop down
    select_ROI.setPlaceholder('Choose an ROI Buffer...');
    // add drop down to console
    print(select_ROI);
    
    ////////////
    // Step 3 //
    ///////////
    // Prepare the imagery
    var step_3_button = ui.Button('Prepare Imagery for Processing');
    step_3_button.onClick(function(){
      print('When the imagery has been prepared, '+
            '\nbuttons will appear to display the imagery;'+
            '\nindicating to add either the contemporary'+
            '\nand/or historic imagery to the map.'+
            '\nDo not proceed before these buttons populate'+
            '\nthe console. Click the buttons to view the '+
            '\nimagery.');
      Map.clear(); // resset the map
      Map.addLayer(ROI, {color: '1E266F'}, "ROI"); //add ROI to map
      
      // clip the known mangrove extent
      var kn_mang_ext = mang_img.clip(ROI);
      
      // Create hist./cont. image collections
      var cont_imagery = c_imagery.conImagery(ROI, contemporary_start_year, contemporary_end_year,
                                              cloud_cover, month_start, month_end, cloud_mask);
      var hist_imagery = h_imagery.histImagery(ROI, historic_start_year, historic_end_year,
                                              cloud_cover, month_start, month_end, cloud_mask).aside(print);
      //Calculate tidal conditions
      cont_imagery = shoreRefl.shoreRefl(cont_imagery, tidalArea, ROI);
      cont_imagery = shoreRefl.tide_bands(cont_imagery);
      
      // build the contemporary BAP composites
      var Chot = ee.ImageCollection(cont_imagery).qualityMosaic('MNDWI');
      var Clot = ee.ImageCollection(cont_imagery).qualityMosaic('inv_MNDWI').aside(print);


      // add the contemporary imagery once it has finished processing 
      Clot.evaluate(function(){
        var add_c_imagery = ui.Button('Add Contemporary Imagery');
        add_c_imagery.onClick(function(){
        //Add to Map
          var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 3000};
          Map.addLayer(Chot, vis, 'Contemporary High Tide');
          Map.addLayer(Clot, vis, 'Contemporary Low Tide');
        });
        print(add_c_imagery);
      });
      
      // determing tidal conditions
      hist_imagery = shoreRefl.shoreRefl(hist_imagery, tidalArea, ROI);
      hist_imagery = shoreRefl.tide_bands(hist_imagery);
      
      //build the historic BAP composites
      var Hhot = ee.ImageCollection(hist_imagery).qualityMosaic('MNDWI');
      var Hlot = ee.ImageCollection(hist_imagery).qualityMosaic('inv_MNDWI');


      // add the historic imagery once it has finished processing
      Hlot.evaluate(function(result){
        var add_h_imagery = ui.Button('Add Historic Imagery');
        add_h_imagery.onClick(function(){
          //Add to Map
          var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 3000};
          Map.addLayer(Hhot, vis, 'Historic High Tide');
          Map.addLayer(Hlot, vis, 'Historic Low Tide');
        });
        print(add_h_imagery);
      });
      
      Chot = Chot.select('B1','B2','B3','B4','B5','B6','B7');
      Clot = Clot.select('B1','B2','B3','B4','B5','B6','B7');
      Hhot = Hhot.select('B1','B2','B3','B4','B5','B6','B7');
      Hlot = Hlot.select('B1','B2','B3','B4','B5','B6','B7');
      
      
      ////////////
      // Step 4 //
      ////////////
      // Calculation of the spectral indices
      var step_4_button = ui.Button('Calculate the Spectral Indices');
      step_4_button.onClick(function(){
        print('When the indices have been calculated'+
            '\nthe imagery and indices will be prepared for export.'+
            '\nThen, an alert will appear in the console when the '+
            '\nindices are calculated. The task tab will turn yellow.');

        // Add single-image indices     
        var Chot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Chot));
        var Clot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Clot));
        var Hhot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Hhot));
        var Hlot1 = ee.Image(indx_mod.addIndex_simple(indx_list, Hlot));
        
        // add SMRI if in list
        var Chot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Chot1).addBands(indx_mod.SMRI(Chot1, Clot1)),  ee.Image(Chot1));
        var Clot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Clot1).addBands(indx_mod.SMRI(Chot1, Clot1)),  ee.Image(Clot1));
        var Hhot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Hhot1).addBands(indx_mod.SMRI(Hhot1, Hlot1)),  ee.Image(Hhot1));
        var Hlot2 = ee.Algorithms.If(indx_list.contains('SMRI'), 
        ee.Image(Hlot1).addBands(indx_mod.SMRI(Hhot1, Hlot1)),  ee.Image(Hlot1));
        
        // add MRI if in list
        var Chot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Chot2).addBands(indx_mod.MRI(Chot2, Clot2)),  ee.Image(Chot2));
        var Clot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Clot2).addBands(indx_mod.MRI(Chot2, Clot2)),  ee.Image(Clot2));
        var Hhot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Hhot2).addBands(indx_mod.MRI(Hhot2, Hlot2)),  ee.Image(Hhot2));
        var Hlot3 = ee.Algorithms.If(indx_list.contains('MRI'), 
        ee.Image(Hlot2).addBands(indx_mod.MRI(Hhot2, Hlot2)),  ee.Image(Hlot2));
        
        // Export Imagery with indices as bands
        Chot3 = ee.Image(Chot3).float();
        Clot3 = ee.Image(Clot3).float();
        Hhot3 = ee.Image(Hhot3).float();
        Hlot3 = ee.Image(Hlot3).float();
        print(Hlot3);
        var test = ee.Image(Hlot3).addBands(ee.Image.constant(2));              
       
        // Export Imagery with indices as bands
        Export.image.toAsset({
            image: ee.Image(Chot3).clip(ROI),
            description: 'HOT_Img_contemporary',
            region: ROI,
            scale: 30,
            maxPixels:1e13,
            dimensions: 512
          });

        Export.image.toAsset({
            image: ee.Image(Clot3).clip(ROI),
            description: 'LOT_Img_contemporary',
            region: ROI,
            scale: 30,
            maxPixels:1e13,
            dimensions: 512
          });

        Export.image.toAsset({
            image: ee.Image(Hhot3).clip(ROI),
            description: 'HOT_Img_historic',
            region: ROI,
            scale: 30,
            maxPixels:1e13,
            dimensions: 512
          });

        Export.image.toAsset({
            image: ee.Image(Hlot3).clip(ROI),
            description: 'LOT_Img_historic',
            region: ROI,
            scale: 30,
            maxPixels:1e13,
            dimensions: 512
          });

        ////////////
        // Step 5 //
        ////////////
        // creating image masks and finalizing images
        var step_5_button = ui.Button('Prepare Image Mask');
        step_5_button.onClick(function(){
          print('When the final mask has been prepared the task tab'+
              '\nwill turn yellow, prompting for export. The final mask'+
              '\nand the other intermediary outputs can be viewed in the'+
              '\npanel by clicking on the corresponding button.'+
              '\n'+
              '\nOnce all hte of intermediary outputs have begun to export'+
              '\nGEEMMM Module 1 is complete. Proceed to GEEMMM Module 2'+
              '\nafter all outputs have successfully been exported and'+
              '\nadded to the asset GEE asset folder.');
        
          // bring in topo data and create the mask
          var dsm = topography.dsm_id(topo, topo_path);
          var topo_mask = topography.topo_mask_func(dsm, kn_mang_ext, 
                                    mang_topo, elevation, slope);
          
          // Use low tide images to create water mask
          
          if(remove_water === true){
              var waterMask = water.water_mask(Hlot3, Clot3, combo_water_mask);
            }else{
              var waterMask = ee.Image(1);
            }
          // combine the topo and water masks
          var combo_masked = waterMask.multiply(topo_mask).eq(1);
          
          // create the fringe mangrove mask
          var fringe_mask = fringe.fringMangrove(dsm, buff_dist, ROI);
          
          // add buttons to view the mask outputs
          var topo_mask_butt = ui.Button('View Topo Mask?');
              topo_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(topo_mask), {}, 'Topographic Mask');});
          var water_mask_butt = ui.Button('View water Mask?');
              water_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(waterMask), {}, 'Water Mask');});
          var combo_mask_butt = ui.Button('View combo Mask?');
              combo_mask_butt.onClick(function(){
                Map.addLayer(ee.Image(combo_masked), {}, 'Combine Mask');});
          
          // fringe mangrove addition to mask or not
          var in_t = function(combo_masked, fringe_mask){
            var final_mask = ee.Image(combo_masked).add(fringe_mask);
            return final_mask;
          };
          var in_f = function(combo_masked){
            var final_mask = combo_masked;
            return final_mask;
          };          
          
          // Final Mask creation
          if(inland_mang === true){var final_mask =  in_t(combo_masked, fringe_mask);
                                       ROI = ee.Geometry.Polygon(ROI.buffer(buff_dist));}
                              else {var final_mask =  in_f(combo_masked);}

          // Export final mask
          Export.image.toAsset({
              image: final_mask,
              description: 'Final_mask',
              region: ROI,
              scale: 30,
              maxPixels:1e13,
              dimensions: 1024
            });
            
          // prep ROI for export
          var ROI_out = ee.FeatureCollection(ee.Feature(ROI, {name: 'ROI'}));
          // export ROI
          Export.table.toAsset({
            collection: ROI_out,
            description: "ROI",
            assetId: 'ROI'
            });
          
          // Create Final Mask Button
          var final_mask_butt = ui.Button('View final Mask?');
              final_mask_butt.onClick(function(){Map.addLayer(ee.Image(final_mask), {}, 'Final Mask');});
              
          // Create Panel
          var mask_panel = ui.Panel({
            layout: ui.Panel.Layout.flow('vertical'),
            style: {width: '300px'}
            });
            
          // Add buttons to the panel
          mask_panel.add(topo_mask_butt);
          mask_panel.add(water_mask_butt);
          mask_panel.add(combo_mask_butt);
          mask_panel.add(final_mask_butt);
          
          //Add the panel to the map
          ui.root.add(mask_panel);

        });
        test.evaluate(function(){ // Safety to not proceed until ready
          print('ALERT: Spectral Indices Successfully Calculated');
          print(step_5_button);});
      });
      print(step_4_button);
    });
    print(step_3_button);
  });
  print(step_2_button);
});
print(step_1_button);

////////////////////////////////////////////////////////////////////////////////  
