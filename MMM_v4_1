/**** Start of imports. If edited, may not auto-convert in the playground. ****/
var coarse_roi = 
    /* color: #23cba7 */
    /* shown: false */
    ee.Geometry.Polygon(
        [[[92.27663115452197, 21.10646474900191],
          [92.28761748264697, 20.932124830460342],
          [92.34254912327197, 20.654815032001945],
          [92.18874052952197, 19.86120364692833],
          [93.56203154514697, 15.391649197546329],
          [96.94582060764697, 15.190298700411923],
          [97.74782256077197, 9.060252352314953],
          [98.45094756077197, 9.667285885379467],
          [98.79152373264697, 10.510960142120705],
          [98.70363310764697, 10.662150633928936],
          [99.41774443577197, 11.761351499658009],
          [98.73659209202197, 13.988899441865396],
          [98.04445342014697, 15.00997991894637],
          [98.35207060764697, 15.857183557194567],
          [97.36655271051744, 18.11602110768812],
          [92.98300778864244, 21.311308584418544]]]);
/***** End of imports. If edited, may not auto-convert in the playground. *****/
///////////////////////////////////////////////////////////
//////////      Mangrove Mapping Methodology     //////////
/////////////////////////////////////////////////////////// 


/* 

This code was developed for Blue Ventures Conservation, by Max Yancho.
Questions about the project and the appliction of the script(s) should be 
directed to Dr. Trevor Jones, Geospatial & Blue Forests Science Advisor 
(trevor@blueventures.org). Questions about the code can be directed to 
Mr. Max Yancho (yanchojo@gmail.com).

Developed in June 3, 2020


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////
//////////////      Step 1       //////////////
///////////////////////////////////////////////


1.A) USER DEFINED DATA SETS
     In this first sub-section the user must determine what data they would 
     like to use within the Mangrove Mapping Methodology (MMM). The options
     mostly fall into one of two options: use GEE data or upload user owned
     data. Additionally, if the user would like, they may file a request to
     Google to add a specific data set into the 'Earth Engine Data Catalog'
     To submit a data request follow the below link:
          https://issuetracker.google.com/issues?q=componentid:184426%2B
          

1.A.a) Set Coare ROI
     The user must first coarsely define their region of interest (ROI). To 
     do so, please use the drawing tools located in the lower left corner of
     the 'Map' to roughly define the part of the world to further investigate
     Note: this is not going to be the ROI used in the data processing, this 
     coarse ROI is to simply help select the target data.
*/

//var draw = require('users/yanchojo/BVC_MMM_V4/:modules/draw_tool');
//draw.coarseROI();


/*
1.A.b) Known Mangrove Extent
     The currently known mangrove extent for the study area will play a key role
     in the further identification of methodological variables (such as slope 
     and elevation thresholds). At this time, the user must identify whether MMM 
     will use the GEE provided Global Mangrove Forests Distribution, v1 (2000) or
     if there is an 'known mangrove' asset which has been upload to the user's 
     account.
     
     Enter:
          var kmx = true; (to use the GEE Global Mangrove Forests Distribution)
          var kmx = false; (to map to the 'known mangrove extent' assest)
*/

var kmx = true;

/*
1.A.c) Coastline Data
     The coastline is a very important data set for this workflow. It will be 
     used to define the actual ROI, as well as to aid in the determination of the
     tidal conditions for each of the landsat images which are to be processed. 
     The GEE layer which is available to use is the Large Scale International 
     Boundary Polygons. Alternatively, like the known mangrove extent, the user 
     may upload their own data as an asset and bring that into the workflow by 
     copying in the asset path into the 'cst_path' variable below.
     
     Enter:
          var cst = true; (the GEE Large Scale International Boundary Polygons)
          var cst = false; (to map to the user's uploaded 'coastline' asset)
                            ^--- Must enter an asset path
*/

var cst = false; 
var cst_path = 'users/yanchojo/gadm36_mmr_0_shore';

/*
1.A.d) Topographic Data 
     Another important variable is that of the topographic data. The topographic 
     data will be used to set elevation and slope thresholds before the 
     classification is executed. The default GEE data is from the JAXA-ALOS 
     satellite radar DSM (30 m). As is the case with the other important data 
     inputs, the user has the choice to upload their own data by filling in the
     'topo_path' variable below.
     
     Enter:
          var topo = true; (to use the GEE JAXA-ALOS satellite radar DSM (30 m))
          var topo = false; (to map to the user's uploaded 'topographic' assest)
                              ^--- Must enter an asset path
*/

var topo = true;
var topo_path = 'users/yanchojo/topo';

/*
1.A.e) Classification Reference Data 
     The most significant input for the classification data is the 
     classification reference data. This data set must be created by the user. 
     This can be done within the GEE environment or externally and uploaded as 
     GEE user asset. To execute the classification, the user will be asked below 
     about several important parameters associated with the classification
     process, but at this time the user must simply identify the classification 
     reference data that will be used to determine the output landcover classes.
     This is a vector dataset. It can be multipoint or multipolygon geometry. 
     It is also imporant that the user declare what field the unique class 
     'label' is recorded in. It should be a unique numeric number.
     
     Enter:
          var class_ref = **PATH**; (Path to the Classification Reference Data)
*/

var class_ref = "users/yanchojo/training_data";
// Landcover labels for the classifier
var label = 'Classvalue';

////////////////////////////////////////////////////////////////////////////////
/*
1.B) USER DEFINED VARIABLE
    In this sub-section, the user will have to define some variables about how 
    the MMM will run. These variables include the historic and contemporary year
    windows, topographic thresholds, cloud cover limits, etc. Each variable will
    be described thoroughly, and helpful resources provided for further insight.


1.B.a) Contemporary Years
     Define the contemporary year window. These years will bookend the data 
     selected. The years selected is completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example 
     below.
     
     Enter:
          var cont_year_1 = 2014; (Older Contemporary year)
          var cont_year_2 = 2018; (Recent Contemporary year)
*/

var cont_year_1 = 2014;
var cont_year_2 = 2018;

/*
1.B.b) Historic Years
     Define the historic year window. These years will bookend the data 
     selected. The years selected is completely up to the user's discretion. Be 
     sure that the two dates are entered in the correct order. See example below.
  
     Enter:
          var hist_year_1 = 2004; (Older Historic year)
          var hist_year_2 = 2008; (Recent Historic year)

*/

var hist_year_1 = 2004;
var hist_year_2 = 2008;

/*
1.B.c) Months of Interest 
     Define the months of interest. Like the year windows of interest, the 
     months of interest entered by the user will be used to filter both of the
     imagery sets (contemporary and historic). Two months are required to be 
     input by the user. If they wish to cover the entire year, ‘1’ and ‘12’ 
     should be selected (for January and December). 
     
     The time of year selected should focus on a few key environmental variables
     that will impact the imagery. These include:
      1.) The contrast of mangrove vegetation from surrounding land cover.
      2.) The persistence of clouds in the region. (dry or wet seasons)
     
     Region-specific knowledge of the study area should be used to support the 
     decision around the selection of seasonal month range. If the user needs to
     learn more about the seasonality of the study area they may refer to the
     RiceAtlas database as one source of seasonality info (Laborte et al, 2017). 
     (shorturl.at/dvwDQ)
     
     Enter:
          (Jan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6, Jul = 7, Aug = 8,
          Sep = 9, Oct = 10, Nov = 11, Dec = 12)
          
          var month_1 = 1; **To select the whole year set to 1**
          var month_2 = 12; **To select the whole year set to 12**
*/

var month_1 = 1;
var month_2 = 12;

/*
1.B.d) Cloud Cover limit  
     The cloud cover limit is a whole number percentage that will be used to 
     filter the Landsat image collection. The cloud cover limit will filter the
     metadata of each image, using the USGS calculated  cloud cover claculated 
     in the Tier 1 products. (shorturl.at/blpK1)
    
     Enter:
          var cloud_cover = 10; (%, 0-100, Integer)

*/

var cloud_cover = 10;

/*
1.B.e) Tidal Zone  
     The tidal zone is a user defined parameter that is used to help the MMM 
     determine the tidal condition for each image, in both the historic and the
     contemporary image sets. The tidal zone is functionally a shoreline buffer
     which extends seawards from the shore. The distance should be the tidally 
     'active' zone, which will contain the majority of the tidal flats and tidal
     islands which would be exposed and then resubmerged given the tidal state.
     
     The default number is 1000 m (1 km). This number can be tailored for the
     specific region of interest. **NOTE: The tidal zone is not the ROI.**
    
     Enter:
          var tidal_zone = 1000; (meters, Integer)

*/

var tidal_zone = 1500;


/*
1.B.f) Classification Reference Data Type
     Record type of classification reference data. It is important for the MMM 
     that the user distinguishes their classification reference data as either
     spatio-temporally invariant across the time-period (historic and
     contemporary imagery) or derived from just contemporary sources. 
     
     1.) Spatio-temporally invariant: The land cover class has not change 
                                      between the historic years of interest
                                      and the contemporary years of interest.
     2.) Contemporary Data: The land cover classes were determined by using just 
                            contemporary sources (i.e. high resolution imagery
                            that was recently acquired)
                            
     These are important distinctions to make. If just contemporary sources are 
     used, the spectral values from the contemporary data will be used to
     classify the historic. If the data is spatio-temporally invariant, the 
     classifier will be retrained for each data set. Spatio-temporally invariant
     classification reference data will provide more accurate classification 
     results. However, it is harder to generate accurately.
     
     Enter:
          var class_ref_type = true; (true, the Reference Data is Spatio-
                                            temporally invariant)
          var class_ref_type = false; (false, the Reference Data is NOT Spatio-
                                            temporally invariant)
*/

var class_ref_type = false;

/*
1.B.g) Classifier
     GEE offers a variety of classifiers. These come in both supervised and 
     unsupervised classifier choices. At this time however, the MMM is built to
     only run the Random Forest Classifier, a supervised decision tree classifier.
     Future versions will offer more classification options.

     Enter:
          var classifier = 'RF'; (To use the Random Forest Classifier)
*/

var classifier = 'RF';
var trees = 200;

/*
1.B.h) Water Mask
     The MMM offers the option to mask out water pixels using the MNDWI index.
     The MNDWI is calculated for the entire ROI and water pixels are removed 
     based on a threshold established in the original paper by Dr. H. Xu (2006).
     If water pixels are not masked, the reference training data must take this 
     into account in some fashion (e.g. "water_class").

     Enter:
          var remove_water = true; (true, mask out the water pixels using MNDWI)
          var remove_water = false; (Water pixels will NOT be masked)
    
    If the water pixels are to be masked, the user has the option to either mask
    pixels which are water in both the historic and contemporary imagery, or to
    just mask pixels that were identified as water in the historic imagery. If 
    the coastline has changed dramatically during the time period of interest, a
    combined maske will be best not to erroneously mask non-water pixels. 
    
    Enter:
          var combo_water_mask = true; (true, mask only pixels identified as 
                                        water in historic and contemporary data)
          var combo_water_mask = false;  (false, mask only pixels identified as 
                                          water in historic data)
*/

var remove_water = true;
var combo_water_mask = true;

/*
1.B.i) Inland Fringing Mangroves
     Studies have shown that inland stands of mangroves may be found at low
     laying elevations which are far from the coatline. For a comprehensive 
     investigation, these exclaves must attempt to be captured. To do so, the 
     ROI can be expanded to 2x for elevations beyond the initial determination.
     Example: If the ROI is determined to be a 25km buffer of the coastline, if 
              'true', the ROI will be expanded to include all pixels between 25 
              and 50 km which also fall at or below 5 m a.s.l.

     Enter:
          var inland_mang = true; (true, double the ROI for pixels <= 5 m a.s.l)
          var inland_mang = false; (false, retain original ROI)
*/

var inland_mang = false;

/*
////////////////////////////////////////////////////////////////////////////////
1.B.j) Topographic Thresholds
     To threshold the data, the user has several options. 1.) The known mangrove
     extent can be used to extract the 99th percentile for slope and elevation
     and use that to generate a topographic mask for the input data. OR 2.) The
     user may enter their own thresholds for both slope and elevation at this 
     time. NOTE: If the user elects to have the data automatically thresholded 
     ('true') then the numbers enter here for the slope and elevation threshold 
     will have no impact on the generation of the topographic mask.

     Enter:
          var mang_topo = true; (true, use the known mangrove extent to determine
                                 the 99th percentiles for slope and elevation, 
                                 and use them to automatically generate a 
                                 topographic mask.)
          var mang_topo = false; (false, use the user defined thresholds to 
                                  generate the topographic mask.)
     
     The user defined topographic thresholds. (discarded if mang_topo = true)
     
     Enter:
          var elevation = 39; (meters, meters above sea level)
          var slope = 16; (%, percent chance in slope)
*/

var mang_topo = true;
var elevation = 39;
var slope = 16;

/*

1.B.k) Output Structure
     The outputs from the MMM methodology can be fashioned in either a combined
     (where the high and low tide data are combined in to a single collection) 
     or seperate (individual high and low) classifications. Outputs below can 
     be turned on and off by adding a 'true'/'false' to the corresponding 
     variable input. The historic and contemporary data is seperable into LOT
     and HOT components. (HOT: Highest Observable Tide; LOT: Lowest Observable
     Tide) These outputs can also be combined into single data outputs where the
     
     Enter:
          var XXX_out = true; (true, Classify and export this composite)
          var XXX_out = false; (false, No action)
*/
var HOT_cont_out = false;        // High tide comtemporary Imagery
var LOT_cont_out = false;        // Low tide comtemporary Imagery
var combo_cont_out = true;     // Combination comtemporary Imagery
var HOT_hist_out = false;        // High tide historic Imagery
var LOT_hist_out = false;        // Low tide historic Imagery
var combo_hist_out = true;     // Combination historic Imagery


/*
1.B.l) Spectral Indices
     There are numerous mangrove specific, vegetation specific, and 
     environmental indices which can be used to aid the classification. 
     Below, is the included list of indices which the user may select from. 
     The user will be prompted in the console to select any index which they 
     would like to include for each dataset moving forward. Note: Some indices,
     like the submerged mangrove recognition index require both high and low tide
     imagery. This will be indicated with (l) for low and (h) for high inputs.
     
     
    #############################################################################
    #    Index    #          Calculation          #        Citation             #
    ############################################################################# 
    #                                                                           #
    #   SR('RVI')   = NIR/Red                                                   #
    #                                                                           #
    #   NDVI        = (NIR-Red)/(NIR+Red)                                       #
    #                                                                           #
    #   NDWI        = (Green-NIR)/(Green+NIR)              Gao 1996             #
    #                                                                           #
    #   MNDWI       = (Green-MIR)/(Green+MIR)              Xu 2006              #
    #                                                                           #
    #   CMRI        = NDVI-NDWI                            Gupta et al. 2018    #
    #                                                                           #
    #   MMRI        = (MNDWI-NDVI)/(MNDWI+NDVI)            Diniz et al. 2018    #
    #                                                                           #
    #   SAVI        = 1.5*(NIR-Red)/(NIR+Red+0.5)                               #
    #                                                                           #
    #   OSAVI       = (NIR-Red)/(NIR+Red+0.16)                                  #
    #                                                                           #
    #   EVI         = 2.5*((NIR–red)/                                           #
    #                       (NIR+6*Red–7.5*Blue+1))                             #
    #                                                                           #
    #   MRI         =  |GVI(l) – GVI(h)|*GVI(l)*          Zhang and Tian 2013   #
    #                                 (WI(l)+WI(h))                             #
    #                                                                           #
    #   SMRI        = (NDVI(l)-NDVI(h))*                  Xia et al. 2018       #
    #                       ((NIR(l)-NIR(h))/(NIR(h))                           # 
    #                                                                           #
    #############################################################################
*/

























////////////////////////////////////////////////////////////////////////////////
// Required Modules

var known_ext =  require('users/yanchojo/BVC_MMM_V4/:modules/known_mangroves');
var coastline =  require('users/yanchojo/BVC_MMM_V4/:modules/coastline');
var topography =  require('users/yanchojo/BVC_MMM_V4/:modules/topography');
var mangrove_buff = require('users/yanchojo/BVC_MMM_V4/:modules/mangrove_buff');
var c_imagery = require('users/yanchojo/BVC_MMM_V4/:modules/contemporary_imagery');
var h_imagery = require('users/yanchojo/BVC_MMM_V4/:modules/historic_imagery');
var shoreRefl = require('users/yanchojo/BVC_MMM_V4/:modules/MNDWI_tidal_function');
var indx_mod = require('users/yanchojo/BVC_MMM_V4/:modules/indices');
var water = require('users/yanchojo/BVC_MMM_V4/:modules/water_mask');
var fringe = require('users/yanchojo/BVC_MMM_V4/:modules/fringe_mang');
var RFclass = require('users/yanchojo/BVC_MMM_V4/:modules/rf_classer');
var evQA = require('users/yanchojo/BVC_MMM_V4/:modules/evaluation');

////////////
// Step 1 //
////////////
var step_1_button = ui.Button('Begin Workflow');
step_1_button.onClick(function(){
  //1.A.a
  //Map.clear(); 
  
  //1.A.b Ingest the known mangrove extent
  var mang_img = known_ext.known_mang(kmx);
  //1.A.c Ingest the topographic data (DSM)
  var dsm = topography.dsm_id(topo);
  //1.A.d Create the coastline from the coarse ROI
  var coast = coastline.coast_In(cst, cst_path, coarse_roi);
  Map.centerObject(coarse_roi);
  
  //Aside: in the meantime create the tidal area buffer
  var tidalArea = coast.simplify(500).buffer(tidal_zone).simplify(500);
  
  //1.B.k Generate the index list
  var indx_list = ee.List([]);
  indx_list = indx_mod.index_list();
  
  ////////////
  // Step 2 //
  ////////////
  var step_2_button = ui.Button('Determine ROI');
  step_2_button.onClick(function(){
 
    //Buffer the known mangrove extent using the coastline
    var mang_buff_img = mangrove_buff.mang_buff(coast, mang_img);

    //Create a table of the mangrove area
    var buffer_table = mangrove_buff.areaTable(mang_buff_img, coarse_roi);

    //Graphically display mangrove area table
    var buffer_chart = mangrove_buff.areaChart(mang_buff_img, coarse_roi); 
    
    //Add the mangrove buffer layers to the map
    Map.addLayer(mang_buff_img.select('35_km'), {palette: ['CC0000']}, '35km_buffer');
    Map.addLayer(mang_buff_img.select('30_km'), {palette: ['FF780A']}, '20km_buffer');
    Map.addLayer(mang_buff_img.select('25_km'), {palette: ['FC9F0D']}, '25km_buffer');
    Map.addLayer(mang_buff_img.select('20_km'), {palette: ['F9CB24']}, '20km_buffer');
    Map.addLayer(mang_buff_img.select('15_km'), {palette: ['74B800']}, '15km_buffer');
    Map.addLayer(mang_buff_img.select('10_km'), {palette: ['3E8F00']}, '10km_buffer');
    Map.addLayer(mang_buff_img.select('05_km'), {palette: ['006600']}, '05km_buffer');
    //Print the chart and table to the console
    print("Mangrove Area by Buffer", buffer_table);
    print(buffer_chart);
    //Have the user set the buffer distance and create ROI.
    var ROI = ee.Geometry(coast);
    var buff_dist = ee.Number(0);
    // list of buffers to choose from
    var buffers = {
     '01_km': [1000], '02.5_km': [2500], '05_km': [5000], '07.5_km': [7500],
     '10_km': [10000], '12.5_km': [12500], '15_km': [15000], '17.5_km': [17500],
     '20_km': [20000], '22.5_km': [22500], '25_km': [25000], '27.5_km': [27500],
     '30_km': [30000], '32.5_km': [32500], '35_km': [35000], '37.5_km': [37500],
     '40_km': [40000], '50_km': [50000], '60_km': [60000], '75_km': [75000],
    };
    // Create drop-down menu to select ROI buffer
    var select_ROI = ui.Select({
      items: Object.keys(buffers),
      onChange: function(key) {
      ROI = coast.buffer(buffers[key][0]);
      buff_dist = ee.Number(buffers[key][0]);
      }
    });

    // Set a place holder for the drop down
    select_ROI.setPlaceholder('Choose a ROI Buffer...');
    // add drop down to console
    print(select_ROI);
    
    ////////////
    // Step 3 //
    ///////////
    // Prepare the imagery
    var step_3_button = ui.Button('Prepare Imagery for Processing');
    step_3_button.onClick(function(){
      print(' When the imagery has been prepared, '+
            '\nbuttons will appear to display the imagery.'+
            '\nDo not proceed before these bottons populate'+
            '\nthe console. Click buttons to view imagery.');
      Map.clear(); // resset the map
      Map.addLayer(ROI, {color: '1E266F'}, "ROI"); //add ROI to map
      
      // clip the known mangrove extent
      var kn_mang_ext = mang_img.clip(ROI);
      
      // Create hist./cont. image collections
      var cont_imagery = c_imagery.conImagery(ROI, cont_year_1, cont_year_2,
                                              cloud_cover, month_1, month_2);
      var hist_imagery = h_imagery.histImagery(ROI, hist_year_1, hist_year_2,
                                              cloud_cover, month_1, month_2);
      //Calculate tidal conditions
      cont_imagery = shoreRefl.shoreRefl(cont_imagery, tidalArea, ROI);
      cont_imagery = shoreRefl.tide_bands(cont_imagery);
      
      // build the contemporary BAP composites
      var Chot = ee.ImageCollection(cont_imagery).qualityMosaic('inv_MNDWI');
      var Clot = ee.ImageCollection(cont_imagery).qualityMosaic('MNDWI').aside(print);
      
      // add the contemporary imagery once it has finished processing 
      Clot.evaluate(function(){
        var add_c_imagery = ui.Button('Add Contemporary Imagery');
        add_c_imagery.onClick(function(){
        //Add to Map
          var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 3000};
          Map.addLayer(Chot, vis, 'Contemporary High Tide');
          Map.addLayer(Clot, vis, 'Contemporary Low Tide');
        });
        print(add_c_imagery);
      });
      
      // determing tidal conditions
      hist_imagery = shoreRefl.shoreRefl(hist_imagery, tidalArea, ROI);
      hist_imagery = shoreRefl.tide_bands(hist_imagery);
      
      //build the historic BAP composites
      var Hhot = ee.ImageCollection(hist_imagery).qualityMosaic('inv_MNDWI');
      var Hlot = ee.ImageCollection(hist_imagery).qualityMosaic('MNDWI');
      
      // add the historic imagery once it has finished processing
      Hlot.evaluate(function(result){
        var add_h_imagery = ui.Button('Add Historic Imagery');
        add_h_imagery.onClick(function(){
          //Add to Map
          var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 3000};
          Map.addLayer(Hhot, vis, 'Historic High Tide');
          Map.addLayer(Hlot, vis, 'Historic Low Tide');
        });
        print(add_h_imagery);
      });
      
      ////////////
      // Step 4 //
      ////////////
      // Calculation of the spectral indices
      var step_4_button = ui.Button('Calculate the Spectral Indices');
      step_4_button.onClick(function(){
        print(' When the indices have been calculated'+
            '\nthe imagery and indices will be prepared to export.'+
            '\nThen, an alert will appear in the console when the '+
            '\nindices are calcualted. The task tab will turn yellow.');
            
        //add simple indices to imagery
        Chot = indx_mod.addIndex_simple(indx_list, Chot);
        Clot = indx_mod.addIndex_simple(indx_list, Clot);
        Hhot = indx_mod.addIndex_simple(indx_list, Hhot);
        Hlot = indx_mod.addIndex_simple(indx_list, Hlot);
        
        //generate combined indices for hist. and cont.
        var cont_ind = indx_mod.addIndex_complex(indx_list, Chot, Clot);
        var hist_ind = indx_mod.addIndex_complex(indx_list, Hhot, Hlot);
        
        // Export Imagery with indices as bands
        Chot = Chot.addBands(cont_ind).uint16();
        Export.image.toDrive({
            image: Chot.clip(ROI),
            description: 'HOT_Img_contemporary',
            region: ROI,
            scale: 30,
            //folder: 'EE_outputs',
            maxPixels:1e13,
            dimensions: 512,
            skipEmptyTiles: true
          });
        Clot = Clot.addBands(cont_ind).uint16();
        Export.image.toDrive({
            image: Clot.clip(ROI),
            description: 'LOT_Img_contemporary',
            region: ROI,
            scale: 30,
            //folder: 'EE_outputs',
            maxPixels:1e13,
            dimensions: 512,
            skipEmptyTiles: true
          });
        Hhot = Hhot.addBands(hist_ind).uint16();
        Export.image.toDrive({
            image: Hhot.clip(ROI),
            description: 'HOT_Img_historic',
            region: ROI,
            scale: 30,
            //folder: 'EE_outputs',
            maxPixels:1e13,
            dimensions: 512,
            skipEmptyTiles: true
          });
        Hlot = Hlot.addBands(hist_ind).uint16();
        Export.image.toDrive({
            image: Hlot.clip(ROI),
            description: 'LOT_Img_historic',
            region: ROI,
            scale: 30,
            //folder: 'EE_outputs',
            maxPixels:1e13,
            dimensions: 512,
            skipEmptyTiles: true
          });

        ////////////
        // Step 5 //
        ////////////
        // creating image masks and finalizing images
        var step_5_button = ui.Button('Prepare Image Mask');
        step_5_button.onClick(function(){
          
          // bring in topo data and create the mask
          var dsm = topography.dsm_id(topo, topo_path);
          var topo_mask = topography.topo_mask_func(dsm, kn_mang_ext, 
                                    mang_topo, elevation, slope);
          
          // Use low tide images to create water mask
          var waterMask = water.water_mask(Hlot, Clot);
          
          // combine the topo and water masks
          var combo_masked = waterMask.multiply(topo_mask).eq(1);
          
          // create the fringe mangrove mask
          var fringe_mask = fringe.fringMangrove(dsm, buff_dist, ROI);
          
          // add buttons to view the mask outputs
          var topo_mask_butt = ui.Button('View Topo Mask?');
              topo_mask_butt.onClick(function(){Map.addLayer(ee.Image(topo_mask), {}, 'Topographic Mask');});
          var water_mask_butt = ui.Button('View water Mask?');
              water_mask_butt.onClick(function(){Map.addLayer(ee.Image(waterMask), {}, 'Water Mask');});
          var combo_mask_butt = ui.Button('View combo Mask?');
              combo_mask_butt.onClick(function(){Map.addLayer(ee.Image(combo_masked), {}, 'Combine Mask');});
          
          // fringe mangrove addition to mask or not
          var in_t = function(combo_masked, fringe_mask){
            var final_mask = ee.Image(combo_masked).add(fringe_mask);
            return final_mask;
          };
          var in_f = function(combo_masked){
            var final_mask = combo_masked;
            return final_mask;
          };          
          
          // Final Mask creation
          if(inland_mang === true){var final_mask =  in_t(combo_masked, fringe_mask);
                                       ROI = ee.Geometry.Polygon(ROI.buffer(buff_dist));}
                              else {var final_mask =  in_f(combo_masked);}

          // Export final mask
          Export.image.toDrive({
              image: final_mask,
              description: 'Final_mask',
              region: ROI,
              scale: 30,
              //folder: 'EE_outputs',
              maxPixels:1e13,
              dimensions: 512,
              skipEmptyTiles: true
            });
          // prep ROI for export
          var ROI_out = ee.FeatureCollection([ee.Feature(ee.Geometry.Polygon(ROI), {name: 'ROI'})]);
          // export ROI
          Export.table.toDrive({
            collection: ROI_out,
            description: "ROI",
            //folder: 'EE_outputs',
            fileFormat: 'SHP'});
          
          // Create Final Mask Button
          var final_mask_butt = ui.Button('View final Mask?');
              final_mask_butt.onClick(function(){Map.addLayer(ee.Image(final_mask), {}, 'Final Mask');});
              
          // Create Panel
          var mask_panel = ui.Panel({
            layout: ui.Panel.Layout.flow('vertical'),
            style: {width: '300px'}
            });
            
          // Add buttons to the panel
          mask_panel.add(topo_mask_butt);
          mask_panel.add(water_mask_butt);
          mask_panel.add(combo_mask_butt);
          mask_panel.add(final_mask_butt);
          
          //Add the panel to the map
          ui.root.add(mask_panel);
          
          ////////////
          // Step 6 //
          ////////////
          // Image Classification
          var step_6_button = ui.Button('Begin Classification');
          step_6_button.onClick(function(){
            ui.root.remove(mask_panel); // remove the mask panel
            
            // Update the image masks
            Chot = Chot.updateMask(final_mask);
            Clot = Clot.updateMask(final_mask);
            Hhot = Hhot.updateMask(final_mask);
            Hlot = Hlot.updateMask(final_mask);
          
            // training polygons
            var t_poly = ee.FeatureCollection(class_ref);

            //Isolate the bands to use in the classification
            var bands = ee.List(['B1', 'B2', 'B3', 'B4', 'B5', 'B7']).cat(indx_list);

            //Classification using RF
            //Contemporary
            if(HOT_cont_out === true){ var Chot_class = RFclass.ChotClassify(Chot, 
                                                    t_poly, label, bands, ROI, trees);}
            if( LOT_cont_out === true){ var CLot_class = RFclass.ClotClassify(Clot, 
                                                    t_poly, label, bands, ROI, trees);}
            if(combo_cont_out === true){ var Ccom_class = RFclass.CcomClassify(Chot, 
                                              Clot, t_poly, label, bands, ROI, trees);}
            //Historic
            if( HOT_hist_out === true){ var Hhot_class = RFclass.HhotClassify(Hhot, 
                              class_ref_type, Chot, t_poly, label, bands, ROI, trees);}
            if(LOT_hist_out === true){ var Hlot_class = RFclass.HlotClassify(Hlot, 
                              class_ref_type, Clot, t_poly, label, bands, ROI, trees);}
            if(combo_hist_out === true){var Hcom_class = RFclass.HcomClassify(Hhot,
                  Hlot, class_ref_type, Chot, Clot, t_poly, label, bands, ROI, trees);}
          
          ////////////
          // Step 7 //
          ////////////
          // Output Evaluation \ QAA
          var step_7_button = ui.Button('Evaluate Results');
          step_7_button.onClick(function(){  
            var ROI_dis = coast.buffer(buff_dist); //recalculate the ROI b/c ¯\_(ツ)_/¯
           
            //hist mangrove
            var hmang = Hcom_class.eq(11).and(Hcom_class.eq(15)
                                  .and(Hcom_class.eq(22)));
            
            //cont mangrove
            var cmang = Ccom_class.eq(11).and(Ccom_class.eq(15)
                                  .and(Ccom_class.eq(22)));
            
            // Add three maps to the screen.
            var left = ui.Map();
            var right = ui.Map();
            var centre = ui.Map();
            ui.Map.Linker([left,right,centre]);
            
            // add maps to the imagery
            ui.root.clear();
            ui.root.add(left);
            ui.root.add(centre);
            ui.root.add(right);
            left.setOptions("SATELLITE");
            
            //Add the Landsat imagery to the map
            var vis = {bands: ['B4', 'B5', 'B3'], min: 0, max: 3000};
            right.addLayer(Chot, vis, 'Contemporary High Tide');
            right.addLayer(Clot, vis, 'Contemporary Low Tide');
            right.addLayer(Hhot, vis, 'Historic High Tide');
            right.addLayer(Hlot, vis, 'Historic Low Tide');

            //ADD ROI
            //Add the ROI to the all maps, in red outline with no fill
            right.addLayer(ROI_dis, {palette: 'black'}, 'ROI');
            centre.addLayer(ROI_dis, {palette: 'black'}, 'ROI');
            left.addLayer(ROI_dis, {palette: 'black'}, 'ROI');
            centre.centerObject(Chot);

            //Contemporary
            if(HOT_cont_out === true){evQA.Chot_display(Chot_class, centre);}
            if(LOT_cont_out === true){evQA.Clot_display(CLot_class, centre);}
            if(combo_cont_out === true){evQA.Ccom_display(Ccom_class, centre);}
            //Historic
            if(HOT_hist_out === true){evQA.Hhot_display(Hhot_class, centre);}
            if(LOT_hist_out === true){evQA.Hlot_display(HLot_class, centre);}
            if(combo_hist_out === true){evQA.Hcom_display(Hcom_class, centre);}

            //Print title
            var title = ui.Label('GEE QAA INTERFACE');
            title.style().set('fontWeight', 'bold');

            title.style().set({
              fontSize: '20px',
              padding: '5px'
            });
            print(title);

            //Print instructions to the console
            var instructions = ui.Label('Use the left map for viewing GE '+
            'imagery\nthe centre map for viewing classification outputs'+
            '\nand the right map for viewing Landsat Composite imagery');
            instructions.style().set('fontWeight', 'bold');
            print(instructions);

            });
            print(step_7_button);                                                        
          });
          print(step_6_button);
        });
        Hlot.evaluate(function(){ // Safety to not proceed until ready
          print('ALERT: Indices Successfully Calculated');
          print(step_5_button);});
      });
      print(step_4_button);
    });
    print(step_3_button);
  });
  print(step_2_button);
});
print(step_1_button);

////////////////////////////////////////////////////////////////////////////////  